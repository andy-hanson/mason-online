extends lib/layout

block content
	section
		p #[code if] and #[code unless] allow you to conditionally execute code.

	mason-editor
		pre.
			. if true
				0
			. if false
				1
			. unless true
				2
			. unless false
				3

	section
		p These return #[+ms('?')] values.
		p If you don't want to return a value, use #[code if!] and #[code unless!].

	mason-editor
		pre.
			. 0
			if! true
				. 1
			unless! false
				. 2

	section
		p These are statements, not expressions.
		p  Since they don't have a value, they can appear as lines in blocks, but never inside other expressions.
		p (No `x = if! ...`)
		p.
			When #[code if] appears in the middle of a line,
			you don't need parentheses --
			the rest of the line automatically gets grouped with the #[code if].
			Most keywords work this way.

	mason-editor
		pre.
			use
				mason.@.? un-?

			# un-? has *1* argument: the `if` expression.
			un-? if true
				0

	+hdr('switch')
	section
		p #[code switch] efficiently branches based on a value.
		p Unlike with JavaScript, you don't need #[code break].
		p Fallthrough is not supported.

	mason-editor
		pre.
			f = |number
				switch number
					0
						"zero"
					else
						"some other number"
			. f 0
			. f 1

	section
		p If there is no #[code else], an error will be thrown for an unhandled case.
		p (If you want to do nothing, just write `pass` in the `else` block.)
		p #[code switch!] is the statement version.


	h1 focus
	section
		p.
			The focus, #[code _], pronounced "it" when reading code,
			is a good short-lived variable when you don't need a name.
		p Several expressions in Mason implicitly assign the focus.
		p You can also assign to it explicitly like any other variable.

		p #[code fun_] is short for #[code (fun _)].

	mason-editor
		pre.
			use
				mason.math.methods * +

			twice = |_
				* _ 2
			half = |_
				* _ 0.5
			two-and-a-half-of = |_
				+ twice_ half_

			_ = 2
			two-and-a-half-of_


	h1 case
	section
		p #[code case] allows any expression as a test.
		p Tests are tried from top to bottom until one matches.

	mason-editor
		pre.
			use
				mason.compare <?

			rate-guess = |a
				case
					<? a 7
						"Too low!"
					<? 7 a
						"Too high!"
					else
						"You got it!"

			. rate-guess 6
			. rate-guess 8
			. rate-guess 7

	section
		p An expression written after #[code case] on the same line will become the focus.
		p Or, when a Fun has only one argument and its body is a #[code case], just use #[code |case].

	mason-editor
		pre.
			use
				mason.compare =?
				mason.math.methods -

			rate-guess = |a
				case a
					=? _ 7
						"You got it!"
					else
						"Off by {- _ 7}"

			. rate-guess 1337

			rate-guess-2 = |case
				=? _ 7
					"You got it!"

			. rate-guess-2 7

	section
		p #[code case!] is the statement version.


	h1 logic
	section
		p All these conditionals are easier with some boolean helpers.

	mason-editor
		pre.
			. not false
			. and true true
			. or true false
			# nand and nor are simply:
			. not and true false
			. not or false false

	section
		p.
			The syntax is similar to function calls,
			but without the need for parentheses because
			the keywords automatically group with the rest of the line,
			just like #[code if], #[code unless], #[code switch], #[code case], and others.
