extends lib/layout

block content
	section
		p #[code class] creates a native JavaScript class.
		p It is the normal way to create a concrete type.
		p The class body consists of a constructor and method definitions.
		p Methods being defined should be #[+ms('Method')]s or strings.
		p (We'll get to #[code Method] creation later.)

	mason-editor
		pre.
			use
				msl.to-string

			# If superclass is missing, it will be Object, so this is just for show.
			Point = class
				construct! x y
					.x ::= x
					.y ::= y

				to-string |
					"({.x} {.y})"

				# The `|` doesn't need a `.` in front; that's implied.
				# It does need `!` and `~` where appropriate.
				"transpose!" !|
					y = .y
					.y := .x
					.x := y

			p = new Point 1 2
			. to-string p
			p.transpose!()
			. to-string p

	+hdr('static')

	section
		p The class itself can have its own functionality.
		p A #[code do!] block sets the focus to the class.
		p #[code static] defines static methods on the class.

	mason-editor
		pre.
			use
				msl.@.@
				msl.@.@-Type empty
				msl.compare =?
				msl.Type.Kind kind!

			Point = class
				do!
					# Point isn't really an @, but I'm here to prove a point.
					kind! _ @
					_.origin = new _ 0 0

				static
					# If it's an @ it should define "empty."
					empty |
						Point.origin
					"from-array" |arr
						assert! =? 2 arr.length
						new Point arr[0] arr[1]

				construct! x y
					.x = x
					.y = y

			. empty Point
			. Point.from-array [ 1 2 ]

	p.
		The parts of a class *must* come in this order:
		#[code do!], #[code static], #[code construct!], then methods.
