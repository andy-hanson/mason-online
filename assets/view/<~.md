A `Generator` is a block of code that yields values to and recieves responses from a context.
These are also known as coroutines.

A Fun returning a Generator! is written with `~|` instead of `|`.
(Or `~!|` instead of `!|`, `.~|` instead of `.|`, or `.~!|` instead of `.!|`.)

`<~`, pronounced "yield", gives a value to the context.
It looks and acts like a normal function, but does not return synchronously.

	use
		msl.@.Seq.Stream

	# The Stream context treats the yielded values as elements of a @.
	new Stream ~|
		<~ 1
		<~ 2
		<~ 3


More specifically, a Generator! is a mutable value which the context calls the `gen-next!` method on, causing it to execute code up until the next yield.
The "context" is the Fun that uses the generator.

They are useful when:

* Code could run on-demand, for example yielding the values of a `Stream` above.
* Code could run asynchronously. For example, `$ing` lets you yield promises and recieve their results later.
* There's some information that you want threaded through everything via a context.
* Your code has a side-effect (such as logging) that you want dealt with by the context rather than directly.

You can also recieve values from the context.

	use
		msl.@.Range
		msl.Generator gen-next!
		msl.math.Number incr

	taking = |stream getter
		generator = getter()
		for stream
			value done = gen-next! generator _
			if! done
				break value

	taking (new Range 0 10) ~|
		. <~
		. <~
		. <~

You can use `a <~ b` to both send a value to the context and take one back (making it the same as same as `a = <~ b`).

Note that `(<~ 1)` is an expression while `local <~ 1` is a statement.

	use
		msl.Generator gen-next!
		msl.math.Number incr

	# Interjects itself into assignments and increments the number.
	incrementing = |yields-numbers
		generator = yields-numbers()
		last-value ::= undefined
		for
			value done = gen-next! generator last-value
			if! done
				break value
			last-value := incr value

	incrementing ~|
		two <~ 1
		three <~ two
		<~ three

You can also let one Generator! delegate to another.
`<~~`, pronounced "yield-to", runs the yielded-to Generator! inside of the same context.

	use
		msl.@.Seq.Stream

	yield-both = ~|a b
		<~ a
		<~ b
	new Stream ~|
		# This is equivalent to `<~~ (yield-both 1 2)`.
		# `<~~` only ever has the one "argument", which is another Generator! to yield to.
		<~~ yield-both 1 2
		<~~ yield-both 1 2
