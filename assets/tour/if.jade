extends _layout

block content
	+hdr('boolean operations')
	section
		p These work just like JavaScript's #[code && || !].
		p In Mason, keywords automatically group with the rest of the line. (Or up until the next closing parenthesis, but due to this rule you'll rarely need parentheses.)
		p Since #[code not] has only one argument, the entire expression after it is its argument.
		p #[code and] and #[code or] expect many arguments, so their arguments are the multiple expressions after them.
		p So, #[code not a b] is #[code not (a b)], but #[code and a b] is #[code (and a b)].
		p Remember, keywords eat up the rest of the line after them.

	mason-editor
		pre.
			. not false
			. and true true
			|| `and`/`or` can take any number of arguments
			. or false false true
			|| nand and nor are simply:
			. not and true false
			. not or false false
			|| The `or` here takes up the rest of the line, so it's parsed as `and true (or false true)`.
			. and true or false true

	section
		p Please don't use these as control structures; they are forbidden to be used as statements. #[code if] handles that instead.

	+hdr('if')

	section
		p #[code if] and #[code unless] return a value only when their condition is true.
		p When used as expressions, these are #[+ms('?')] values.
		p These parse the block specially by taking it for theirselves before anything else can.

	mason-editor
		pre.
			. if true 0
			. if (or true false) 1
			. unless not true
				2
			|| `unless` eats the block before `and` can, so this works:
			. unless and true false
				3
			|| `un-?` has *1* argument; `if` eats the rest of the line.
			|| (un-? gets an option's value or throws.)
			. un-? if true 4

	section
		p There is no #[code else] expression to go with #[code if]; use #[code cond] or #[code case] (both below) instead.

	+hdr('cond')
	section
		p For simple conditionals, use #[code cond]. This is like JavaScript's ternary operator.
		p Like anything else, the "else" value can go in a block. What if you want blocks for both "then" and "else"? Use #[a(href='#case') #[code case]].

	mason-editor
		pre.
			. cond true 'then 'else
			. cond false 'then
				'else

	+hdr('switch')
	section
		p This is just like JavaScript's.
		p You don't need to #[code break] explicitly. Fallthrough is not supported.
		p To handle multiple cases the same way, just write multiple values on one line.
		p #[code else] handles anything not covered by another case.

	mason-editor
		pre.
			f = |number
				switch number
					0
						"zero"
					1 2
						"a small number"
					else
						"some other number"
			. f 0
			. f 1
			. f 2
			. f 3

	section
		p If there is no #[code else], an error will be thrown for an unhandled case.
		p (If you really want to do nothing, just write #[code pass] in the #[code else] block.)

	+hdr('focus')
	section
		p.
			The focus, #[code _], is a good short-lived variable when you don't need a name.
		p There's some helpful syntax for using it:
		ul
			li Many expressions implicitly assign to the focus.
			li #[code fun_] is short for #[code (fun _)].
			li #[code :Type] is short for #[code _:Type]. (See #[a(href='./type') types])

	+hdr('case')
	section
		p #[code case] allows any expression as a test.
		p Tests are tried from top to bottom until one matches.
		p Just like #[code switch], a missing #[code else] compiles to throwing an error.
		p An expression written after #[code case] on the same line will become the focus.

	mason-editor
		pre.
			rate-guess = |guess
				case guess
					|| implicitly, `_ = guess`
					&lt? _ 7
						"Too low!"
					&gt? _ 7
						"Too high!"
					else
						"You got it!"

			. rate-guess 6
			. rate-guess 8
			. rate-guess 7

	section
		p  Use #[code |case] or #[code |switch] and it will implicitly make the focus the argument.

	mason-editor
		pre.
			rate-guess = |case
				=? _ 7
					"You got it!"
				else
					"Off by {- _ 7}"

			. rate-guess 1337

			rate-guess-2 = |switch
				7
					"You got it!"

			. rate-guess-2 7
