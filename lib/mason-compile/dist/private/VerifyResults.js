'use strict';

(function (global, factory) {
	if (typeof define === "function" && define.amd) {
		define(['exports', './context'], factory);
	} else if (typeof exports !== "undefined") {
		factory(exports, require('./context'));
	} else {
		var mod = {
			exports: {}
		};
		factory(mod.exports, global.context);
		global.VerifyResults = mod.exports;
	}
})(this, function (exports, _context) {
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Modules = exports.Blocks = undefined;

	class VerifyResults {
		constructor() {
			this.localAccessToDeclare = new Map();
			this.localDeclareToAccesses = new Map();
			this.names = new Map();
			this.builtinPathToNames = new Map();
			this.superCallToMethod = new Map();
			this.constructorToSuper = new Map();
			this.blockToKind = new Map();
			this.statements = new Set();
			this.objEntryExports = new Set();
			this.moduleKind = null;
			this.loopsNeedingLabel = new Set();
			this.breaksInSwitch = new Set();
		}

		localDeclareForAccess(localAccess) {
			return this.localAccessToDeclare.get(localAccess);
		}

		name(expr) {
			const name = this.names.get(expr);
			(0, _context.check)(name !== undefined, expr.loc, 'Expression must be placed in a position where name can be determined.');
			return name;
		}

		opName(expr) {
			const x = this.names.get(expr);
			return x === undefined ? null : x;
		}

		isStatement(expr) {
			return this.statements.has(expr);
		}

		blockKind(block) {
			return this.blockToKind.get(block);
		}

		isObjEntryExport(objEntry) {
			return this.objEntryExports.has(objEntry);
		}

		constructorHasSuper(ctr) {
			return this.constructorToSuper.has(ctr);
		}

		loopNeedsLabel(loop) {
			return this.loopsNeedingLabel.has(loop);
		}

		isBreakInSwitch(breakAst) {
			return this.breaksInSwitch.has(breakAst);
		}

	}

	exports.default = VerifyResults;
	const Blocks = exports.Blocks = {
		Do: 0,
		Throw: 1,
		Return: 2,
		Bag: 3,
		Map: 4,
		Obj: 5
	};
	const Modules = exports.Modules = {
		Do: 0,
		Val: 1,
		Exports: 2,
		Bag: 3,
		Map: 4
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcml2YXRlL1ZlcmlmeVJlc3VsdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FNcUIsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21CQUFiLGFBQWE7T0FtR3JCLE1BQU0sV0FBTixNQUFNLEdBQUc7QUFDckIsSUFBRSxFQUFFLENBQUM7QUFDTCxPQUFLLEVBQUUsQ0FBQztBQUNSLFFBQU0sRUFBRSxDQUFDO0FBQ1QsS0FBRyxFQUFFLENBQUM7QUFDTixLQUFHLEVBQUUsQ0FBQztBQUNOLEtBQUcsRUFBRSxDQUFDO0VBQ047T0FHWSxPQUFPLFdBQVAsT0FBTyxHQUFHO0FBQ3RCLElBQUUsRUFBRSxDQUFDO0FBQ0wsS0FBRyxFQUFFLENBQUM7QUFDTixTQUFPLEVBQUUsQ0FBQztBQUNWLEtBQUcsRUFBRSxDQUFDO0FBQ04sS0FBRyxFQUFFLENBQUM7RUFDTiIsImZpbGUiOiJWZXJpZnlSZXN1bHRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjaGVja30gZnJvbSAnLi9jb250ZXh0J1xuXG4vKipcblJlc3VsdHMgb2Yge0BsaW5rIHZlcmlmeX0uXG5UaGlzIGlzIG9ubHkgdGhlIGRhdGEgbmVlZGVkIGJ5IHtAbGluayB0cmFuc3BpbGV9LlxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcmlmeVJlc3VsdHMge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvKipcblx0XHRMb2NhbEFjY2VzcyAtPiBMb2NhbERlY2xhcmUuXG5cdFx0TmVlZGVkIGJlY2F1c2UgbGF6eSBhY2Nlc3NlcyBtdXN0IGJlIGNvbXBpbGVkIGRpZmZlcmVudGx5LlxuXHRcdCovXG5cdFx0dGhpcy5sb2NhbEFjY2Vzc1RvRGVjbGFyZSA9IG5ldyBNYXAoKVxuXHRcdC8qKlxuXHRcdExvY2FsRGVjbGFyZSAtPiBBcnJheVtMb2NhbEFjY2Vzc10uXG5cdFx0RGVidWcgbG9jYWxzIHdpbGwgbm90IGJlIG91dHB1dCBpZiBub3QgaW4gZGVidWcgbW9kZS5cblx0XHQqL1xuXHRcdHRoaXMubG9jYWxEZWNsYXJlVG9BY2Nlc3NlcyA9IG5ldyBNYXAoKVxuXHRcdC8qKlxuXHRcdE1hcHMgQ2xhc3MvRnVuIHRvIG5hbWUgaWYgb25lIGlzIGFwcHJvcHJpYXRlLlxuXHRcdE1hcHMgKmV2ZXJ5KiB7QGxpbmsgU3BlY2lhbFZhbHMuTmFtZX0gdG8gdGhlIG5lYXJlc3QgbmFtZS5cblx0XHQqL1xuXHRcdHRoaXMubmFtZXMgPSBuZXcgTWFwKClcblx0XHQvKipcblx0XHRTdHJpbmcgLT4gU2V0LlxuXHRcdEZvciBlYWNoIHBhdGgsIHRoZSBuYW1lcyBvZiBlYWNoIGJ1aWx0aW4gaW1wb3J0ZWQuXG5cdFx0TGlrZSB0aGUgaW52ZXJzZSBvZiBjb250ZXh0Lm9wdHMuYnVpbHRpbk5hbWVUb1BhdGgsXG5cdFx0YnV0IG9ubHkgaW5jbHVkZXMgbmFtZXMgYWN0dWFsbHkgdXNlZC5cblx0XHQqL1xuXHRcdHRoaXMuYnVpbHRpblBhdGhUb05hbWVzID0gbmV3IE1hcCgpXG5cdFx0LyoqIFZhbHVlcyBhcmUgZWl0aGVyIE1ldGhvZEltcGwgb3IgdGhlIHN0cmluZyAnY29uc3RydWN0b3InICovXG5cdFx0dGhpcy5zdXBlckNhbGxUb01ldGhvZCA9IG5ldyBNYXAoKVxuXHRcdC8qKiBMaW5rcyBhIGNvbnN0cnVjdG9yIHRvIGl0cyBzdXBlciEgY2FsbC4gKi9cblx0XHR0aGlzLmNvbnN0cnVjdG9yVG9TdXBlciA9IG5ldyBNYXAoKVxuXHRcdC8qKiBTdG9yZXMgdmVyaWZpZWQgYmxvY2sga2luZCAoc2VlIHZlcmlmeUJsb2NrLmpzKSAqL1xuXHRcdHRoaXMuYmxvY2tUb0tpbmQgPSBuZXcgTWFwKClcblx0XHQvKipcblx0XHRTZXQgb2YgTXNBc3RzIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBhcyBiZWluZyBzdGF0ZW1lbnRzLlxuXHRcdFRob3NlIHdoaWNoIGFyZSBhbHdheXMgc3RhdGVtZW50cyAobGlrZSBUaHJvdykgYXJlIG5vdCBtYXJrZWQuXG5cdFx0VXNlIGEgc2V0IG9mIHN0YXRlbWVudHMgYmVjYXVzZSB0aGVyZSBhcmUgdXN1YWxseSBtYW55IG1vcmUgdmFscyB0aGFuIHN0YXRlbWVudHMuXG5cdFx0Ki9cblx0XHR0aGlzLnN0YXRlbWVudHMgPSBuZXcgU2V0KClcblx0XHQvKiogT2JqRW50cnlfcyB0aGF0IGFyZSBtb2R1bGUgZXhwb3J0cyAqL1xuXHRcdHRoaXMub2JqRW50cnlFeHBvcnRzID0gbmV3IFNldCgpXG5cdFx0LyoqIEB0eXBlIHtNb2R1bGVzfSAqL1xuXHRcdHRoaXMubW9kdWxlS2luZCA9IG51bGxcblx0XHQvKiogU2V0IG9mIHtAbGluayBMb29wfXMgd2l0aCBhdCBsZWFzdCBvbmUge0BsaW5rIEJyZWFrfSBpbiBhIHtAbGluayBTd2l0Y2h9LiAqL1xuXHRcdHRoaXMubG9vcHNOZWVkaW5nTGFiZWwgPSBuZXcgU2V0KClcblx0XHQvKiogU2V0IG9mIHtAbGluayBCcmVha31zIHRoYXQgYXJlIGluc2lkZSB7QGxpbmsgU3dpdGNofWVzLiAqL1xuXHRcdHRoaXMuYnJlYWtzSW5Td2l0Y2ggPSBuZXcgU2V0KClcblx0fVxuXG5cdC8qKiBHZXRzIHRoZSBMb2NhbERlY2xhcmUgdGhhdCB3YXMgdmVyaWZpZWQgdG8gYmUgdGhlIG9uZSBhY2Nlc3NlZC4gKi9cblx0bG9jYWxEZWNsYXJlRm9yQWNjZXNzKGxvY2FsQWNjZXNzKSB7XG5cdFx0cmV0dXJuIHRoaXMubG9jYWxBY2Nlc3NUb0RlY2xhcmUuZ2V0KGxvY2FsQWNjZXNzKVxuXHR9XG5cblx0LyoqIEdldCBjbG9zZXN0IGFzc2lnbm1lbnQgbmFtZSB0byBhbiBleHByZXNzaW9uLiAqL1xuXHRuYW1lKGV4cHIpIHtcblx0XHRjb25zdCBuYW1lID0gdGhpcy5uYW1lcy5nZXQoZXhwcilcblx0XHRjaGVjayhuYW1lICE9PSB1bmRlZmluZWQsIGV4cHIubG9jLFxuXHRcdFx0J0V4cHJlc3Npb24gbXVzdCBiZSBwbGFjZWQgaW4gYSBwb3NpdGlvbiB3aGVyZSBuYW1lIGNhbiBiZSBkZXRlcm1pbmVkLicpXG5cdFx0cmV0dXJuIG5hbWVcblx0fVxuXG5cdC8qKlxuXHRHZXQgY2xvc2VzdCBhc3NpZ25tZW50IG5hbWUgdG8gYW4gZXhwcmVzc2lvbixcblx0b3IgYG51bGxgIGlmIG5vbmUgaXMgYXZhaWxhYmxlLlxuXHQqL1xuXHRvcE5hbWUoZXhwcikge1xuXHRcdGNvbnN0IHggPSB0aGlzLm5hbWVzLmdldChleHByKVxuXHRcdHJldHVybiB4ID09PSB1bmRlZmluZWQgPyBudWxsIDogeFxuXHR9XG5cblx0LyoqIENlcnRhaW4gZXhwcmVzc2lvbnMgKHN1Y2ggYXMgYGlmYCkgYXJlIG1hcmtlZCBpZiB0aGV5IGFyZSBzdGF0ZW1lbnRzLiAqL1xuXHRpc1N0YXRlbWVudChleHByKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhdGVtZW50cy5oYXMoZXhwcilcblx0fVxuXG5cdC8qKiBXaGF0IGtpbmQgb2YgYmxvY2sgdGhlIHZlcmlmaWVyIGRldGVybWluZWQgdGhpcyB0byBiZS4gKi9cblx0YmxvY2tLaW5kKGJsb2NrKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmxvY2tUb0tpbmQuZ2V0KGJsb2NrKVxuXHR9XG5cblx0LyoqIFdoZXRoZXIgYW4gT2JqRW50cnkgaXMgYSBtb2R1bGUgZXhwb3J0LiAqL1xuXHRpc09iakVudHJ5RXhwb3J0KG9iakVudHJ5KSB7XG5cdFx0cmV0dXJuIHRoaXMub2JqRW50cnlFeHBvcnRzLmhhcyhvYmpFbnRyeSlcblx0fVxuXG5cdGNvbnN0cnVjdG9ySGFzU3VwZXIoY3RyKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3JUb1N1cGVyLmhhcyhjdHIpXG5cdH1cblxuXHQvKiogV2hldGhlciBzb21lIGBicmVha2AgaW4gdGhpcyBsb29wIGlzIGluIGEgYHN3aXRjaGAuICovXG5cdGxvb3BOZWVkc0xhYmVsKGxvb3ApIHtcblx0XHRyZXR1cm4gdGhpcy5sb29wc05lZWRpbmdMYWJlbC5oYXMobG9vcClcblx0fVxuXG5cdC8qKiBSZXR1cm5zIHdoZXRoZXIgdGhlcmUgaXMgYSBgc3dpdGNoYCBpbiBiZXR3ZWVuIHRoaXMgYGJyZWFrYCBhbmQgaXRzIGxvb3AuICovXG5cdGlzQnJlYWtJblN3aXRjaChicmVha0FzdCkge1xuXHRcdHJldHVybiB0aGlzLmJyZWFrc0luU3dpdGNoLmhhcyhicmVha0FzdClcblx0fVxufVxuXG4vKiogS2luZHMgb2Yge0BsaW5rIEJsb2NrfS4gKi9cbmV4cG9ydCBjb25zdCBCbG9ja3MgPSB7XG5cdERvOiAwLFxuXHRUaHJvdzogMSxcblx0UmV0dXJuOiAyLFxuXHRCYWc6IDMsXG5cdE1hcDogNCxcblx0T2JqOiA1XG59XG5cbi8qKiBLaW5kcyBvZiB7QGxpbmsgTW9kdWxlfS4gKi9cbmV4cG9ydCBjb25zdCBNb2R1bGVzID0ge1xuXHREbzogMCxcblx0VmFsOiAxLFxuXHRFeHBvcnRzOiAyLFxuXHRCYWc6IDMsXG5cdE1hcDogNFxufVxuIl19