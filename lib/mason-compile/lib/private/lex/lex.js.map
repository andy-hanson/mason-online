{"version":3,"sources":["private/lex/lex.js","private/lex/lex.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAV,EAAmB;AAChB,QAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,OAAP,KAAmB,QAA1B,EAAoC;AAClE,YAAI,IAAI,QAAQ,OAAR,EAAiB,OAAjB,CAAJ,CAD8D,IAC3B,MAAM,SAAN,EAAiB,OAAO,OAAP,GAAiB,CAAjB,CAArB;KADvC,MAGK,IAAI,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAP,EAAY;AACjD,eAAO,CAAC,SAAD,EAAY,SAAZ,EAAuB,eAAvB,EAAwC,gBAAxC,EAA0D,YAA1D,EAAwE,iBAAxE,CAAP,EAAmG,OAAnG,EADiD;KAAhD;CAJR,CAAD,CAOG,UAAU,OAAV,EAAmB,OAAnB,EAA4B;AAC3B,iBAD2B;;ACP/B,UAAA,QAAA,QAAkB,eAAlB,CAAA,CDO+B;ACL/B,UAAA,iBAAA,QAAgE,gBAAhE,CAAA,CDK+B;ACJ/B,UAAA,aAAA,QAAqB,YAArB,CAAA,CDI+B;ACH/B,UAAA,kBAAA,QAAsC,iBAAtC,CAAA,CDG+B;ACI/B,aAAA,GAAA,CAA4B,YAA5B,EAAgD;AAE/C,YAAI,CAAC,aAAa,QAAb,CAAsB,IAAtB,CAAD,EACH,eAAe,CAAA,GAAG,YAAH,EAAe,EAAf,CAAf,CADD;AAQA,uBAAe,CAAA,GAAG,YAAH,EAAe,EAAf,CAAf,CAV+C;AAY/C,uBAAA,iBAAA,GAZ+C;AAa/C,wBAAA,kBAAA,CAAmB,YAAnB,EAb+C;AAe/C,uBAAA,QAAA,CAAS,MAAA,GAAA,CAAI,KAAJ,CAAT,CAf+C;AAiB/C,mBAAA,OAAA,CAAS,KAAT,EAjB+C;AAmB/C,cAAM,SAAS,gBAAA,GAAA,EAAT,CAnByC;AAoB/C,eAAoB,eAAA,oBAAA,CAAqB,MAArB,CAApB,CApB+C;KAAhD;AAAA,WAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA,EDJ+B;AAkB3B,YAAQ,OAAR,GAAkB,GAAlB,CAlB2B;CAA5B,CAPH","file":"private/lex/lex.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/Loc', './groupContext', './lexPlain', './sourceContext'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    const Loc_1 = require('esast/lib/Loc');\n    const groupContext_1 = require('./groupContext');\n    const lexPlain_1 = require('./lexPlain');\n    const sourceContext_1 = require('./sourceContext');\n    function lex(sourceString) {\n        if (!sourceString.endsWith('\\n'))\n            sourceString = `${sourceString}\\n`;\n        sourceString = `${sourceString}\\0`;\n        groupContext_1.setupGroupContext();\n        sourceContext_1.setupSourceContext(sourceString);\n        groupContext_1.openLine(Loc_1.Pos.start);\n        lexPlain_1.default(false);\n        const endPos = sourceContext_1.pos();\n        return groupContext_1.tearDownGroupContext(endPos);\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = lex;\n});\n","import {Pos} from 'esast/lib/Loc'\nimport {GroupBlock} from '../token/Group'\nimport {openLine, setupGroupContext, tearDownGroupContext} from './groupContext'\nimport lexPlain from './lexPlain'\nimport {pos, setupSourceContext} from './sourceContext'\n\n/**\nLexes the source code into [[Token]]s.\nThe Mason lexer also groups tokens as part of lexing.\nThis makes writing a recursive-descent parser easy.\n*/\nexport default function lex(sourceString: string): GroupBlock {\n\t// Algorithm requires trailing newline to close any blocks.\n\tif (!sourceString.endsWith('\\n'))\n\t\tsourceString = `${sourceString}\\n`\n\n\t/*\n\tUse a 0-terminated string so that we can use `0` as a switch case in lexPlain.\n\tThis is faster than checking whether index === length.\n\t(If we check past the end of the string we get `NaN`, which can't be switched on.)\n\t*/\n\tsourceString = `${sourceString}\\0`\n\n\tsetupGroupContext()\n\tsetupSourceContext(sourceString)\n\n\topenLine(Pos.start)\n\n\tlexPlain(false)\n\n\tconst endPos = pos()\n\treturn <GroupBlock> tearDownGroupContext(endPos)\n}\n"],"sourceRoot":"/source/"}