{"version":3,"sources":["private/lex/chars.js","private/lex/chars.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAV,EAAmB;AAChB,QAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,OAAP,KAAmB,QAA1B,EAAoC;AAClE,YAAI,IAAI,QAAQ,OAAR,EAAiB,OAAjB,CAAJ,CAD8D,IAC3B,MAAM,SAAN,EAAiB,OAAO,OAAP,GAAiB,CAAjB,CAArB;KADvC,MAGK,IAAI,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAP,EAAY;AACjD,eAAO,CAAC,SAAD,EAAY,SAAZ,CAAP,EAA+B,OAA/B,EADiD;KAAhD;CAJR,CAAD,CAOG,UAAU,OAAV,EAAmB,OAAnB,EAA4B;AAC3B,iBAD2B;;ACL/B,aAAA,aAAA,CAA8B,CAA9B,EAAqC;AACpC,eAAO,MAAM,EAAN,IAAiB,MAAM,EAAN,CADY;KAArC;AAAgB,YAAA,aAAA,GAAa,aAAb,CDKe;ACD/B,aAAA,YAAA,CAA6B,CAA7B,EAAoC;AACnC,eAAO,QAAQ,CAAR,EAAW,EAAX,EAAoB,EAApB,CAAP,CADmC;KAApC;AAAgB,YAAA,YAAA,GAAY,YAAZ,CDCe;ACG/B,aAAA,cAAA,CAA+B,CAA/B,EAAsC;AACrC,eAAO,QAAQ,CAAR,EAAW,EAAX,EAAoB,EAApB,CAAP,CADqC;KAAtC;AAAgB,YAAA,cAAA,GAAc,cAAd,CDHe;ACO/B,aAAA,UAAA,CAA2B,CAA3B,EAAkC;AACjC,eAAO,eAAe,CAAf,KAAqB,QAAQ,CAAR,EAAW,EAAX,EAAmB,GAAnB,CAArB,CAD0B;KAAlC;AAAgB,YAAA,UAAA,GAAU,UAAV,CDPe;ACW/B,aAAA,OAAA,CAAiB,CAAjB,EAA0B,GAA1B,EAAqC,GAArC,EAA8C;AAC7C,eAAO,OAAO,CAAP,IAAY,KAAK,GAAL,CAD0B;KAA9C;AAIA,aAAA,eAAA,CAAgC,CAAhC,EAAuC;AAEtC,eAAO,EAAE,IAAI,eAAe,MAAf,IAAyB,eAAe,CAAf,MAAsB,CAAtB,CAA/B,CAF+B;KAAvC;AAAgB,YAAA,eAAA,GAAe,eAAf,CDfe;ACsB/B,UAAM,iBAAiB,IAAI,UAAJ,CAAe,GAAf,CAAjB,CDtByB;ACuB/B,SAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,GAAJ,EAAS,GAAzB,EACC,eAAe,CAAf,IAAoB,CAApB,CADD;AAEA,UAAM,oBAAoB,CACzB,EADyB,EAEzB,EAFyB,EAGzB,EAHyB,EAIzB,EAJyB,EAKzB,EALyB,EAMzB,EANyB,EAOzB,GAPyB,EAQzB,GARyB,EASzB,GATyB,EAUzB,EAVyB,EAWzB,EAXyB,EAYzB,EAZyB,EAazB,EAbyB,EAczB,EAdyB,EAezB,EAfyB,EAgBzB,CAhByB,EAkBzB,EAlByB,EAmBzB,EAnByB,EAoBzB,EApByB,EAqBzB,EArByB,EAsBzB,EAtByB,CAApB,CDzByB;ACiD/B,SAAK,MAAM,CAAN,IAAW,iBAAhB,EACC,eAAe,CAAf,IAAoB,CAApB,CADD;CDjDG,CAPH","file":"private/lex/chars.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    function isDigitBinary(_) {\n        return _ === 48 || _ === 49;\n    }\n    exports.isDigitBinary = isDigitBinary;\n    function isDigitOctal(_) {\n        return inRange(_, 48, 55);\n    }\n    exports.isDigitOctal = isDigitOctal;\n    function isDigitDecimal(_) {\n        return inRange(_, 48, 57);\n    }\n    exports.isDigitDecimal = isDigitDecimal;\n    function isDigitHex(_) {\n        return isDigitDecimal(_) || inRange(_, 97, 102);\n    }\n    exports.isDigitHex = isDigitHex;\n    function inRange(_, min, max) {\n        return min <= _ && _ <= max;\n    }\n    function isNameCharacter(_) {\n        return !(_ < nameCharacters.length && nameCharacters[_] === 0);\n    }\n    exports.isNameCharacter = isNameCharacter;\n    const nameCharacters = new Uint8Array(128);\n    for (let i = 0; i < 128; i++)\n        nameCharacters[i] = 1;\n    const notNameCharacters = [\n        96,\n        38,\n        40,\n        41,\n        91,\n        93,\n        123,\n        125,\n        124,\n        58,\n        39,\n        34,\n        46,\n        32,\n        10,\n        9,\n        35,\n        94,\n        92,\n        59,\n        44\n    ];\n    for (const _ of notNameCharacters)\n        nameCharacters[_] = 0;\n});\n","import Char from 'typescript-char/Char'\n\nexport function isDigitBinary(_: Char): boolean {\n\treturn _ === Char._0 || _ === Char._1\n}\n\nexport function isDigitOctal(_: Char): boolean {\n\treturn inRange(_, Char._0, Char._7)\n}\n\nexport function isDigitDecimal(_: Char): boolean {\n\treturn inRange(_, Char._0, Char._9)\n}\n\nexport function isDigitHex(_: Char): boolean {\n\treturn isDigitDecimal(_) || inRange(_, Char.a, Char.f)\n}\n\nfunction inRange(_: Char, min: Char, max: Char): boolean {\n\treturn min <= _ && _ <= max\n}\n\nexport function isNameCharacter(_: Char): boolean {\n\t// Anything > 128 is a valid name character.\n\treturn !(_ < nameCharacters.length && nameCharacters[_] === 0)\n}\n\n// This tests as slightly faster than using a switch statement.\n// 0: is not a name character; 1: is a name character.\nconst nameCharacters = new Uint8Array(128)\nfor (let i = 0; i < 128; i++)\n\tnameCharacters[i] = 1\nconst notNameCharacters = [\n\tChar.Backtick,\n\tChar.Ampersand,\n\tChar.OpenParenthesis,\n\tChar.CloseParenthesis,\n\tChar.OpenBracket,\n\tChar.CloseBracket,\n\tChar.OpenBrace,\n\tChar.CloseBrace,\n\tChar.Bar,\n\tChar.Colon,\n\tChar.SingleQuote,\n\tChar.DoubleQuote,\n\tChar.Period,\n\tChar.Space,\n\tChar.LineFeed,\n\tChar.Tab,\n\t// Reserved characters:\n\tChar.Hash,\n\tChar.Caret,\n\tChar.Backslash,\n\tChar.Semicolon,\n\tChar.Comma\n]\nfor (const _ of notNameCharacters)\n\tnameCharacters[_] = 0\n"],"sourceRoot":"/source/"}