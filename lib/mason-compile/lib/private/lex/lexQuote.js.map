{"version":3,"sources":["private/lex/lexQuote.js"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAV,EAAmB;AAChB,QAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,OAAP,KAAmB,QAA1B,EAAoC;AAClE,YAAI,IAAI,QAAQ,OAAR,EAAiB,OAAjB,CAAJ,CAD8D,IAC3B,MAAM,SAAN,EAAiB,OAAO,OAAP,GAAiB,CAAjB,CAArB;KADvC,MAGK,IAAI,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAP,EAAY;AACjD,eAAO,CAAC,SAAD,EAAY,SAAZ,EAAuB,eAAvB,EAAwC,YAAxC,EAAsD,gBAAtD,EAAwE,gBAAxE,EAA0F,SAA1F,EAAqG,SAArG,EAAgH,gBAAhH,EAAkI,WAAlI,EAA+I,YAA/I,EAA6J,iBAA7J,CAAP,EAAwL,OAAxL,EADiD;KAAhD;CAJR,CAAD,CAOG,UAAU,OAAV,EAAmB,OAAnB,EAA4B;AAC3B,iBAD2B;;AAE3B,UAAM,QAAQ,QAAQ,eAAR,CAAR,CAFqB;AAG3B,UAAM,YAAY,QAAQ,YAAR,CAAZ,CAHqB;AAI3B,UAAM,UAAU,QAAQ,gBAAR,CAAV,CAJqB;AAK3B,UAAM,UAAU,QAAQ,gBAAR,CAAV,CALqB;AAM3B,UAAM,SAAS,QAAQ,SAAR,CAAT,CANqB;AAO3B,UAAM,UAAU,QAAQ,SAAR,CAAV,CAPqB;AAQ3B,UAAM,iBAAiB,QAAQ,gBAAR,CAAjB,CARqB;AAS3B,UAAM,YAAY,QAAQ,WAAR,CAAZ,CATqB;AAU3B,UAAM,aAAa,QAAQ,YAAR,CAAb,CAVqB;AAW3B,UAAM,kBAAkB,QAAQ,iBAAR,CAAlB,CAXqB;AAY3B,aAAS,QAAT,CAAkB,MAAlB,EAA0B,QAA1B,EAAoC;AAChC,cAAM,cAAc,SAAS,CAAT,CADY;AAEhC,cAAM,aAAa,gBAAgB,aAAhB,EAAb,CAF0B;AAGhC,YAAI,UAAJ,EAAgB;AACZ,kBAAM,eAAe,gBAAgB,eAAhB,CAAgC,CAAhC,CAAf,CADM;AAEZ,sBAAU,KAAV,CAAgB,iBAAiB,WAAjB,EAA8B,gBAAgB,GAAhB,EAAqB,KAAK,EAAE,kBAAF,CAAxE,CAFY;SAAhB;AAIA,YAAI,OAAO,EAAP,CAP4B;AAQhC,iBAAS,GAAT,CAAa,GAAb,EAAkB;AACd,mBAAO,CAAC,GAAE,IAAH,EAAQ,GAAE,GAAV,EAAc,CAArB,CADc;SAAlB;AAGA,iBAAS,OAAT,CAAiB,IAAjB,EAAuB;AACnB,gBAAI,OAAO,YAAP,CAAoB,IAApB,CAAJ,EADmB;SAAvB;AAGA,iBAAS,eAAT,GAA2B;AACvB,gBAAI,SAAS,EAAT,EAAa;AACb,+BAAe,iBAAf,CAAiC,IAAI,QAAQ,WAAR,CAAoB,IAAxB,EAA8B,IAA9B,CAAjC,EADa;AAEb,uBAAO,EAAP,CAFa;aAAjB;SADJ;AAMA,iBAAS,SAAT,GAAqB;AACjB,mBAAO,MAAM,OAAN,CAAc,UAAd,CAAyB,gBAAgB,GAAhB,EAAzB,CAAP,CADiB;SAArB;AAGA,cAAM,YAAY,WAAW,QAAQ,WAAR,GAAsB,QAAQ,UAAR,CAvBnB;AAwBhC,uBAAe,SAAf,CAAyB,YAAY,KAAZ,EAAmB,SAA5C,EAxBgC;AAyBhC,kBAAU,OAAO,IAAP,EAAa;AACnB,kBAAM,OAAO,gBAAgB,GAAhB,EAAP,CADa;AAEnB,oBAAQ,IAAR;AACI,qBAAK,EAAL;AAAS;AACL,8BAAM,OAAO,gBAAgB,GAAhB,EAAP,CADD;AAEL,4BAAI,SAAS,EAAT,IAAe,UAAU,WAAW,EAAX,GAAgB,EAAhB,CAAV,EACf,QAAQ,IAAR,EADJ,KAGI,IAAI,CAAC,EAAD,GAAK,OAAO,YAAP,CAAoB,IAApB,CAAL,EAA+B,CAAnC,EAHJ;AAIA,8BANK;qBAAT;AADJ,qBASS,EAAL;AACI,sCADJ;AAEI,wBAAI,gBAAgB,MAAhB,CAAuB,EAAvB,CAAJ,EAAgC;AAC5B,8BAAM,IAAI,WAAJ,CADsB;AAE5B,uCAAe,iBAAf,CAAiC,CAAjC,EAF4B;AAG5B,mCAAW,OAAX,CAAmB,IAAnB,EAH4B;qBAAhC,MAKK;AACD,8BAAM,WAAW,gBAAgB,GAAhB,EAAX,CADL;AAED,8BAAM,YAAY,gBAAgB,GAAhB,EAAZ,CAFL;AAGD,kCAAU,KAAV,CAAgB,QAAQ,eAAR,CAAwB,SAAxB,CAAhB,EAAoD,gBAAgB,GAAhB,EAAqB,KAAK,EAAE,gBAAF,CAA9E,CAHC;AAID,kCAAU,OAAV,CAAkB,QAAlB,EAA4B,IAA5B,EAJC;qBALL;AAWA,0BAbJ;AATJ,qBAuBS,EAAL;AAAS;AACL,8BAAM,cAAc,gBAAgB,GAAhB,EAAd,CADD;AAEL,oCAAY,MAAZ,GAAqB,YAAY,MAAZ,GAAqB,CAArB,CAFhB;AAGL,kCAAU,KAAV,CAAgB,UAAhB,EAA4B,gBAAgB,GAAhB,EAAqB,KAAK,EAAE,aAAF,CAAtD,CAHK;AAIL,8BAAM,cAAc,gBAAgB,YAAhB,EAAd,CAJD;AAKL,8BAAM,YAAY,gBAAgB,eAAhB,CAAgC,CAAhC,CAAZ,CALD;AAML,4BAAI,YAAY,WAAZ,EAAyB;AACzB,4CAAgB,YAAhB,CAA6B,WAA7B,EAA0C,cAAc,SAAd,CAA1C,CADyB;AAEzB,mCAAO,MAAP,CAAc,gBAAgB,IAAhB,OAA2B,EAA3B,CAAd,CAFyB;AAGzB,kCAAM,QAAN,CAHyB;yBAA7B,MAMI,IAAI,KAAK,MAAL,CAAY,WAAZ,IAA2B,KAAK,MAAL,CAAY,YAAY,WAAZ,CAAvC,CAAJ,CANJ;AAOA,8BAbK;qBAAT;AAvBJ,qBAsCS,EAAL;AACI,wBAAI,QAAJ;AACI,4BAAI,UAAJ,EACI,QAAQ,IAAR,EADJ,KAGI,MAAM,QAAN,CAHJ;2BAKA,IAAI,MAAJ,EANJ;AAOA,0BARJ;AAtCJ,qBA+CS,EAAL;AACI,wBAAI,CAAC,QAAD,IAAa,CAAC,UAAD,EACb,MAAM,QAAN,CADJ,KAGI,QAAQ,IAAR,EAHJ;AAIA,0BALJ;AA/CJ;AAsDQ,4BAAQ,IAAR,EADJ;AArDJ,aAFmB;SAAb;AA2DV,0BApFgC;AAqFhC,YAAI,QAAJ,EACI,eAAe,QAAf,CAAwB,KAAxB,GAAgC,gBAAhC,CADJ,KAGI,mBAAmB,eAAe,QAAf,CAAnB,CAHJ;AAIA,uBAAe,UAAf,CAA0B,gBAAgB,GAAhB,EAA1B,EAAiD,SAAjD,EAzFgC;KAApC;AA2FA,WAAO,cAAP,CAAsB,OAAtB,EAA+B,YAA/B,EAA6C,EAAE,OAAO,IAAP,EAA/C,EAvG2B;AAwG3B,YAAQ,OAAR,GAAkB,QAAlB,CAxG2B;AAyG3B,aAAS,kBAAT,CAA4B,UAA5B,EAAwC;AACpC,cAAM,SAAS,WAAW,SAAX,CADqB;AAEpC,YAAI,OAAO,MAAP,KAAkB,CAAlB,EAAqB;AACrB,kBAAM,OAAO,OAAO,CAAP,CAAP,CADe;AAErB,gBAAI,gBAAgB,QAAQ,WAAR,IAAuB,OAAO,KAAK,KAAL,CAA9C,EACA,UAAU,IAAV,CAAe,gBAAgB,GAAhB,EAAf,EAAsC,KAAK,EAAE,kBAAF,CAAqB,KAAK,KAAL,CAA1B,CAAtC,CADJ;SAFJ;KAFJ;AAQA,aAAS,MAAT,CAAgB,GAAhB,EAAqB;AACjB,cAAM,MAAM,IAAI,UAAJ,CAAe,CAAf,CAAN,CADW;AAEjB,YAAI,QAAQ,cAAR,CAAuB,GAAvB,KAA+B,QAAQ,GAAR,EAC/B,OAAO,KAAP,CADJ;AAEA,aAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,IAAI,MAAJ,EAAY,IAAI,IAAI,CAAJ,EAChC,IAAI,CAAC,QAAQ,eAAR,CAAwB,IAAI,UAAJ,CAAe,CAAf,CAAxB,CAAD,EACA,OAAO,KAAP,CADJ;AAEJ,eAAO,IAAP,CAPiB;KAArB;AASA,aAAS,cAAT,GAA0B;AACtB,YAAI,QAAQ,EAAR,CADkB;AAEtB,aAAK,MAAM,EAAN,IAAY,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,CAAjB,EACI,IAAI,gBAAgB,MAAhB,CAAuB,EAAvB,CAAJ,EACI,QAAQ,QAAQ,OAAO,YAAP,CAAoB,EAApB,CAAR,CADZ;AAEJ,eAAO,KAAP,CALsB;KAA1B;CA1HD,CAPH","file":"private/lex/lexQuote.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/Loc', '../context', '../token/Group', '../token/Token', '../util', './chars', './groupContext', './lexName', './lexPlain', './sourceContext'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    const Loc_1 = require('esast/lib/Loc');\n    const context_1 = require('../context');\n    const Group_1 = require('../token/Group');\n    const Token_1 = require('../token/Token');\n    const util_1 = require('../util');\n    const chars_1 = require('./chars');\n    const groupContext_1 = require('./groupContext');\n    const lexName_1 = require('./lexName');\n    const lexPlain_1 = require('./lexPlain');\n    const sourceContext_1 = require('./sourceContext');\n    function lexQuote(indent, isRegExp) {\n        const quoteIndent = indent + 1;\n        const isIndented = sourceContext_1.tryEatNewline();\n        if (isIndented) {\n            const actualIndent = sourceContext_1.skipWhileEquals(9);\n            context_1.check(actualIndent === quoteIndent, sourceContext_1.pos, _ => _.tooMuchIndentQuote);\n        }\n        let read = '';\n        function add(str) {\n            read = `${read}${str}`;\n        }\n        function addChar(char) {\n            add(String.fromCharCode(char));\n        }\n        function maybeOutputRead() {\n            if (read !== '') {\n                groupContext_1.addToCurrentGroup(new Token_1.StringToken(null, read));\n                read = '';\n            }\n        }\n        function locSingle() {\n            return Loc_1.default.singleChar(sourceContext_1.pos());\n        }\n        const groupType = isRegExp ? Group_1.GroupRegExp : Group_1.GroupQuote;\n        groupContext_1.openGroup(locSingle().start, groupType);\n        eatChars: while (true) {\n            const char = sourceContext_1.eat();\n            switch (char) {\n                case 92: {\n                    const next = sourceContext_1.eat();\n                    if (next === 35 || next === (isRegExp ? 96 : 34))\n                        addChar(next);\n                    else\n                        add(`\\\\${String.fromCharCode(next)}`);\n                    break;\n                }\n                case 35:\n                    maybeOutputRead();\n                    if (sourceContext_1.tryEat(40)) {\n                        const l = locSingle();\n                        groupContext_1.openInterpolation(l);\n                        lexPlain_1.default(true);\n                    }\n                    else {\n                        const startPos = sourceContext_1.pos();\n                        const firstChar = sourceContext_1.eat();\n                        context_1.check(chars_1.isNameCharacter(firstChar), sourceContext_1.pos, _ => _.badInterpolation);\n                        lexName_1.default(startPos, true);\n                    }\n                    break;\n                case 10: {\n                    const originalPos = sourceContext_1.pos();\n                    originalPos.column = originalPos.column - 1;\n                    context_1.check(isIndented, sourceContext_1.pos, _ => _.unclosedQuote);\n                    const numNewlines = sourceContext_1.skipNewlines();\n                    const newIndent = sourceContext_1.skipWhileEquals(9);\n                    if (newIndent < quoteIndent) {\n                        sourceContext_1.stepBackMany(originalPos, numNewlines + newIndent);\n                        util_1.assert(sourceContext_1.peek() === 10);\n                        break eatChars;\n                    }\n                    else\n                        add('\\n'.repeat(numNewlines) + '\\t'.repeat(newIndent - quoteIndent));\n                    break;\n                }\n                case 96:\n                    if (isRegExp)\n                        if (isIndented)\n                            addChar(char);\n                        else\n                            break eatChars;\n                    else\n                        add('\\\\\\`');\n                    break;\n                case 34:\n                    if (!isRegExp && !isIndented)\n                        break eatChars;\n                    else\n                        addChar(char);\n                    break;\n                default:\n                    addChar(char);\n            }\n        }\n        maybeOutputRead();\n        if (isRegExp)\n            groupContext_1.curGroup.flags = lexRegExpFlags();\n        else\n            warnForSimpleQuote(groupContext_1.curGroup);\n        groupContext_1.closeGroup(sourceContext_1.pos(), groupType);\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = lexQuote;\n    function warnForSimpleQuote(quoteGroup) {\n        const tokens = quoteGroup.subTokens;\n        if (tokens.length === 1) {\n            const name = tokens[0];\n            if (name instanceof Token_1.StringToken && isName(name.value))\n                context_1.warn(sourceContext_1.pos(), _ => _.suggestSimpleQuote(name.value));\n        }\n    }\n    function isName(str) {\n        const cc0 = str.charCodeAt(0);\n        if (chars_1.isDigitDecimal(cc0) || cc0 === 126)\n            return false;\n        for (let i = 0; i < str.length; i = i + 1)\n            if (!chars_1.isNameCharacter(str.charCodeAt(i)))\n                return false;\n        return true;\n    }\n    function lexRegExpFlags() {\n        let flags = '';\n        for (const ch of [103, 105, 109, 121])\n            if (sourceContext_1.tryEat(ch))\n                flags = flags + String.fromCharCode(ch);\n        return flags;\n    }\n});\n"],"sourceRoot":"/source/"}