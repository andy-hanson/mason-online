{"version":3,"sources":["private/verify/context.js","private/verify/context.ts"],"names":[],"mappings":"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","file":"private/verify/context.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", '../VerifyResults', './verifyLocals'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    const VerifyResults_1 = require('../VerifyResults');\n    const verifyLocals_1 = require('./verifyLocals');\n    function setup() {\n        exports.locals = new Map();\n        exports.pendingBlockLocals = [];\n        exports.funKind = 0;\n        exports.okToNotUse = new Set();\n        exports.opLoop = null;\n        exports.method = null;\n        exports.results = new VerifyResults_1.default();\n    }\n    exports.setup = setup;\n    function tearDown() {\n        exports.locals = exports.okToNotUse = exports.opLoop = exports.pendingBlockLocals = exports.method = exports.results = null;\n    }\n    exports.tearDown = tearDown;\n    function withLoop(newLoop, action) {\n        const oldLoop = exports.opLoop;\n        exports.opLoop = newLoop;\n        action();\n        exports.opLoop = oldLoop;\n    }\n    exports.withLoop = withLoop;\n    function withMethod(newMethod, action) {\n        const oldMethod = exports.method;\n        exports.method = newMethod;\n        action();\n        exports.method = oldMethod;\n    }\n    exports.withMethod = withMethod;\n    function withName(newName, action) {\n        const oldName = exports.name;\n        exports.name = newName;\n        action();\n        exports.name = oldName;\n    }\n    exports.withName = withName;\n    function withIife(action) {\n        withLoop(null, () => {\n            withInSwitch(false, action);\n        });\n    }\n    exports.withIife = withIife;\n    function withIifeIf(cond, action) {\n        if (cond)\n            withIife(action);\n        else\n            action();\n    }\n    exports.withIifeIf = withIifeIf;\n    function withIifeIfVal(sk, action) {\n        withIifeIf(sk === 1, action);\n    }\n    exports.withIifeIfVal = withIifeIfVal;\n    function setPendingBlockLocals(val) {\n        exports.pendingBlockLocals = val;\n    }\n    exports.setPendingBlockLocals = setPendingBlockLocals;\n    function withInSwitch(newInSwitch, action) {\n        const oldInSwitch = exports.isInSwitch;\n        exports.isInSwitch = newInSwitch;\n        action();\n        exports.isInSwitch = oldInSwitch;\n    }\n    exports.withInSwitch = withInSwitch;\n    function withFun(funKind, action) {\n        verifyLocals_1.withBlockLocals(() => {\n            withInFunKind(funKind, () => {\n                withIife(action);\n            });\n        });\n    }\n    exports.withFun = withFun;\n    function withMethods(action) {\n        withFun(0, action);\n    }\n    exports.withMethods = withMethods;\n    function withInFunKind(newFunKind, action) {\n        const oldFunKind = exports.funKind;\n        exports.funKind = newFunKind;\n        action();\n        exports.funKind = oldFunKind;\n    }\n});\n","import Op from 'op/Op'\nimport {Constructor} from '../ast/Class'\nimport {MethodImplLike} from '../ast/classTraitCommon'\nimport {Funs} from '../ast/Fun'\nimport {LocalDeclare} from '../ast/locals'\nimport Loop from '../ast/Loop'\nimport VerifyResults from '../VerifyResults'\nimport SK from './SK'\nimport {withBlockLocals} from './verifyLocals'\n\n/** Map from names to LocalDeclares. */\nexport let locals: Map<string, LocalDeclare>\n/** Locals that don't have to be accessed. */\nexport let okToNotUse: Set<LocalDeclare>\nexport let opLoop: Op<{loop: Loop, sk: SK}>\n/**\nLocals for this block.\nThese are added to locals when entering a Function or lazy evaluation.\nIn:\n\ta = |\n\t\tb\n\tb = 1\n`b` will be a pending local.\nHowever:\n\ta = b\n\tb = 1\nwill fail to verify, because `b` comes after `a` and is not accessed inside a function.\nIt would work for `~a is b`, though.\n*/\nexport let pendingBlockLocals: Array<LocalDeclare>\n/**\nKind of function we are currently in.\n(Funs.Plain if not in a function.)\n*/\nexport let funKind: Funs\n/** Current method we are in, or a Constructor, or null. */\nexport let method: Op<Constructor | MethodImplLike>\nexport let results: VerifyResults\n/** Name of the closest AssignSingle. */\nexport let name: string\n/**\nWhether we're in a `switch` inside of a `for`.\nIf there's a `break` statement, the loop will need a label.\n*/\nexport let isInSwitch: boolean\n\nexport function setup(): void {\n\tlocals = new Map()\n\tpendingBlockLocals = []\n\tfunKind = Funs.Plain\n\tokToNotUse = new Set()\n\topLoop = null\n\tmethod = null\n\tresults = new VerifyResults()\n}\n\n// Release for garbage collection.\nexport function tearDown(): void {\n\tlocals = okToNotUse = opLoop = pendingBlockLocals = method = results = null\n}\n\nexport function withLoop(newLoop: Op<{loop: Loop, sk: SK}>, action: () => void): void {\n\tconst oldLoop = opLoop\n\topLoop = newLoop\n\taction()\n\topLoop = oldLoop\n}\n\nexport function withMethod(newMethod: Constructor | MethodImplLike, action: () => void): void {\n\tconst oldMethod = method\n\tmethod = newMethod\n\taction()\n\tmethod = oldMethod\n}\n\nexport function withName(newName: string, action: () => void): void {\n\tconst oldName = name\n\tname = newName\n\taction()\n\tname = oldName\n}\n\n/** Can't break out of loop inside of IIFE. */\nexport function withIife(action: () => void): void {\n\twithLoop(null, () => {\n\t\twithInSwitch(false, action)\n\t})\n}\n\nexport function withIifeIf(cond: boolean, action: () => void): void {\n\tif (cond)\n\t\twithIife(action)\n\telse\n\t\taction()\n}\n\n/** The value form of some expressions need to be wrapped in an IIFE. */\nexport function withIifeIfVal(sk: SK, action: () => void): void {\n\twithIifeIf(sk === SK.Val, action)\n}\n\n// TODO:ES6 Shouldn't need this\nexport function setPendingBlockLocals(val: Array<LocalDeclare>): void {\n\tpendingBlockLocals = val\n}\n\nexport function withInSwitch(newInSwitch: boolean, action: () => void): void {\n\tconst oldInSwitch = isInSwitch\n\tisInSwitch = newInSwitch\n\taction()\n\tisInSwitch = oldInSwitch\n}\n\nexport function withFun(funKind: Funs, action: () => void): void {\n\twithBlockLocals(() => {\n\t\twithInFunKind(funKind, () => {\n\t\t\twithIife(action)\n\t\t})\n\t})\n}\n\nexport function withMethods(action: () => void): void {\n\twithFun(Funs.Plain, action)\n}\n\nfunction withInFunKind(newFunKind: Funs, action: () => void): void {\n\tconst oldFunKind = funKind\n\tfunKind = newFunKind\n\taction()\n\tfunKind = oldFunKind\n}\n"],"sourceRoot":"/source/"}