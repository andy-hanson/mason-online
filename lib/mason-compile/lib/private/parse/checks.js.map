{"version":3,"sources":["private/parse/checks.js","private/parse/checks.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAV,EAAmB;AAChB,QAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,OAAP,KAAmB,QAA1B,EAAoC;AAClE,YAAI,IAAI,QAAQ,OAAR,EAAiB,OAAjB,CAAJ,CAD8D,IAC3B,MAAM,SAAN,EAAiB,OAAO,OAAP,GAAiB,CAAjB,CAArB;KADvC,MAGK,IAAI,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAP,EAAY;AACjD,eAAO,CAAC,SAAD,EAAY,SAAZ,EAAuB,YAAvB,EAAqC,kBAArC,CAAP,EAAiE,OAAjE,EADiD;KAAhD;CAJR,CAAD,CAOG,UAAU,OAAV,EAAmB,OAAnB,EAA4B;AAC3B,iBAD2B;;ACN/B,UAAA,YAAA,QAA0B,YAA1B,CAAA,CDM+B;ACJ/B,UAAA,YAAA,QAA6C,kBAA7C,CAAA,CDI+B;ACC/B,aAAA,UAAA,CAA2B,MAA3B,EAAiD,OAAjD,EAAiF;AAChF,kBAAA,KAAA,CAAM,OAAO,OAAP,EAAN,EAAwB,OAAO,GAAP,EAAY,OAApC,EADgF;KAAjF;AAAgB,YAAA,UAAA,GAAU,UAAV,CDDe;ACM/B,aAAA,aAAA,CAA8B,MAA9B,EAAoD,OAApD,EAAoF;AACnF,kBAAA,KAAA,CAAM,CAAC,OAAO,OAAP,EAAD,EAAmB,OAAO,GAAP,EAAY,OAArC,EADmF;KAApF;AAAgB,YAAA,aAAA,GAAa,aAAb,CDNe;ACW/B,aAAA,YAAA,CAA6B,OAA7B,EAA0C,KAA1C,EAAsD;AACrD,kBAAA,KAAA,CAAM,UAAA,SAAA,CAAU,OAAV,EAAmB,KAAnB,CAAN,EAAiC,MAAM,GAAN,EAAW,KAAK,EAAE,eAAF,CAAkB,OAAlB,CAAL,CAA5C,CADqD;KAAtD;AAAgB,YAAA,YAAA,GAAY,YAAZ,CDXe;ACgB/B,aAAA,UAAA,CAA2B,KAA3B,EAAuC;AACtC,eAAO,UAAA,IAAA,CAAK,MAAM,GAAN,EAAW,KACtB,iBAAiB,UAAA,eAAA,GAAkB,EAAE,YAAF,CAAe,MAAM,IAAN,CAAlD,GAAgE,EAAE,UAAF,CAAa,KAAb,CAAhE,CADD,CADsC;KAAvC;AAAgB,YAAA,UAAA,GAAU,UAAV,CDhBe;CAA5B,CAPH","file":"private/parse/checks.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", '../context', '../token/Keyword'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    const context_1 = require('../context');\n    const Keyword_1 = require('../token/Keyword');\n    function checkEmpty(tokens, message) {\n        context_1.check(tokens.isEmpty(), tokens.loc, message);\n    }\n    exports.checkEmpty = checkEmpty;\n    function checkNonEmpty(tokens, message) {\n        context_1.check(!tokens.isEmpty(), tokens.loc, message);\n    }\n    exports.checkNonEmpty = checkNonEmpty;\n    function checkKeyword(keyword, token) {\n        context_1.check(Keyword_1.isKeyword(keyword, token), token.loc, _ => _.expectedKeyword(keyword));\n    }\n    exports.checkKeyword = checkKeyword;\n    function unexpected(token) {\n        return context_1.fail(token.loc, _ => token instanceof Keyword_1.KeywordReserved ? _.reservedWord(token.kind) : _.unexpected(token));\n    }\n    exports.unexpected = unexpected;\n});\n","import CompileError from '../../CompileError'\nimport {check, fail} from '../context'\nimport Language from '../languages/Language'\nimport {isKeyword, KeywordReserved, Kw} from '../token/Keyword'\nimport Token from '../token/Token'\nimport Slice from './Slice'\n\n/** Throw if `tokens` has content. */\nexport function checkEmpty(tokens: Slice<Token>, message: (_: Language) => string): void {\n\tcheck(tokens.isEmpty(), tokens.loc, message)\n}\n\n/** Throw if `tokens` is empty. */\nexport function checkNonEmpty(tokens: Slice<Token>, message: (_: Language) => string): void {\n\tcheck(!tokens.isEmpty(), tokens.loc, message)\n}\n\n/** Throw if the token is not the expected keyword. */\nexport function checkKeyword(keyword: Kw, token: Token): void {\n\tcheck(isKeyword(keyword, token), token.loc, _ => _.expectedKeyword(keyword))\n}\n\n/** CompileError about encountering an unparseable token. */\nexport function unexpected(token: Token): CompileError {\n\treturn fail(token.loc, _ =>\n\t\ttoken instanceof KeywordReserved ? _.reservedWord(token.kind) : _.unexpected(token))\n}\n"],"sourceRoot":"/source/"}