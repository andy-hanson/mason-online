{"version":3,"sources":["util.js","util.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAO,EAAE;AAChB,QAAI,OAAO,MAAM,KAAK,QAAQ,IAAI,OAAO,MAAM,CAAC,OAAO,KAAK,QAAQ,EAAE;AAClE,YAAI,CAAC,GAAG,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,AAAC,IAAI,CAAC,KAAK,SAAS,EAAE,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC;KAC9E,MACI,IAAI,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,EAAE;AACjD,cAAM,CAAC,CAAC,SAAS,EAAE,SAAS,EAAE,uBAAuB,EAAE,sBAAsB,EAAE,sBAAsB,EAAE,mBAAmB,EAAE,qBAAqB,EAAE,qBAAqB,CAAC,EAAE,OAAO,CAAC,CAAC;KACvL;CACJ,CAAA,CAAE,UAAU,OAAO,EAAE,OAAO,EAAE;AAC3B,gBAAY,CAAC;;ACPjB,QAAA,aAAA,GAAA,OAAA,CAAwB,uBACxB,CAAC,CAD8C;AAC/C,QAAA,YAAA,GAAA,OAAA,CACQ,sBACR,CAAC,CAD6B;AAC9B,QAAA,YAAA,GAAA,OAAA,CAAuB,sBACvB,CAAC,CAD4C;AAC7C,QAAA,SAAA,GAAA,OAAA,CAA4B,mBAC5B,CAAC,CAD8C;AAE/C,QAAA,WAAA,GAAA,OAAA,CAA6C,qBAC7C,CAAC,CADiE;AAClE,QAAA,mBAAA,GAAA,OAAA,CAA+C,qBAG/C,CAAC,CAHmE;AAGpE,aAAA,UAAA,CAA2B,IAAY,EAAA;AACtC,eAAO,IAAI,YAAA,CAAA,OAAU,CAAC,mBAAA,CAAA,OAAgB,CAAC,IAAI,CAAC,CAAC,CAAA;KAC7C;AAFe,WAAA,CAAA,UAAU,GAAA,UAEzB,CAAA;AAGD,aAAA,GAAA,CAAoC,GAAM,EAAE,GAAQ,EAAA;AACnD,WAAG,CAAC,GAAG,GAAG,GAAG,CAAA;AACb,eAAO,GAAG,CAAA;KACV;AAHe,WAAA,CAAA,GAAG,GAAA,GAGlB,CAAA;AAMD,aAAA,MAAA,CAAuB,MAAkB,EAAE,YAAoB,EAAA;AAC9D,eAAO,mBAAA,CAAA,cAAc,CAAC,YAAY,CAAC,GAClC,IAAI,YAAA,CAAA,qBAAqB,CAAC,MAAM,EAAE,IAAI,YAAA,CAAA,OAAU,CAAC,YAAY,CAAC,CAAC,GAC/D,IAAI,YAAA,CAAA,wBAAwB,CAAC,MAAM,EAAE,IAAI,SAAA,CAAA,aAAa,CAAC,YAAY,CAAC,CAAC,CAAA;KACtE;AAJe,WAAA,CAAA,MAAM,GAAA,MAIrB,CAAA;AAGD,aAAA,mBAAA,CAAoC,YAAoB,EAAA;AACvD,eAAO,mBAAA,CAAA,cAAc,CAAC,YAAY,CAAC,GAClC,IAAI,YAAA,CAAA,OAAU,CAAC,YAAY,CAAC,GAC5B,IAAI,SAAA,CAAA,aAAa,CAAC,YAAY,CAAC,CAAA;KAChC;AAJe,WAAA,CAAA,mBAAmB,GAAA,mBAIlC,CAAA;AAMD,aAAA,aAAA,CAA8B,GAAyC,EAAA;AACtE,eAAO,GAAG,YAAY,WAAA,CAAA,OAAS,IAAI,GAAG,YAAY,aAAA,CAAA,OAAW,GAC5D,GAAG,GACH,IAAI,WAAA,CAAA,mBAAmB,CAAC,GAAG,CAAC,CAAA;KAC7B;AAJe,WAAA,CAAA,aAAa,GAAA,aAI5B,CAAA;CDJA,CAAC,CAAC","file":"util.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/Declaration', 'esast/lib/Expression', 'esast/lib/Identifier', 'esast/lib/Literal', 'esast/lib/Statement', './mangle-identifier'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Declaration_1 = require('esast/lib/Declaration');\n    var Expression_1 = require('esast/lib/Expression');\n    var Identifier_1 = require('esast/lib/Identifier');\n    var Literal_1 = require('esast/lib/Literal');\n    var Statement_1 = require('esast/lib/Statement');\n    var mangle_identifier_1 = require('./mangle-identifier');\n    function identifier(name) {\n        return new Identifier_1.default(mangle_identifier_1.default(name));\n    }\n    exports.identifier = identifier;\n    function loc(ast, loc) {\n        ast.loc = loc;\n        return ast;\n    }\n    exports.loc = loc;\n    function member(object, propertyName) {\n        return mangle_identifier_1.propertyNameOk(propertyName) ?\n            new Expression_1.MemberExpressionPlain(object, new Identifier_1.default(propertyName)) :\n            new Expression_1.MemberExpressionComputed(object, new Literal_1.LiteralString(propertyName));\n    }\n    exports.member = member;\n    function propertyIdOrLiteral(propertyName) {\n        return mangle_identifier_1.propertyNameOk(propertyName) ?\n            new Identifier_1.default(propertyName) :\n            new Literal_1.LiteralString(propertyName);\n    }\n    exports.propertyIdOrLiteral = propertyIdOrLiteral;\n    function toLineContent(ast) {\n        return ast instanceof Statement_1.default || ast instanceof Declaration_1.default ?\n            ast :\n            new Statement_1.ExpressionStatement(ast);\n    }\n    exports.toLineContent = toLineContent;\n});\n","import Node from 'esast/lib/Node'\nimport Declaration from 'esast/lib/Declaration'\nimport Expression, {MemberExpression, MemberExpressionPlain, MemberExpressionComputed\n\t} from 'esast/lib/Expression'\nimport Identifier from 'esast/lib/Identifier'\nimport {LiteralString} from 'esast/lib/Literal'\nimport Loc from 'esast/lib/Loc'\nimport Statement, {ExpressionStatement} from 'esast/lib/Statement'\nimport mangleIdentifier, {propertyNameOk} from './mangle-identifier'\n\n/** Mangles name and makes an [[Identifier]]. */\nexport function identifier(name: string): Identifier {\n\treturn new Identifier(mangleIdentifier(name))\n}\n\n/** Assigns `loc` to `ast` and returns it. */\nexport function loc<A extends Node>(ast: A, loc: Loc): A {\n\tast.loc = loc\n\treturn ast\n}\n\n/**\nCreates a member expression for `propertyName` in `object`,\nusing dot syntax (`a.b`) if possible, and falling back to `a['b']`.\n*/\nexport function member(object: Expression, propertyName: string): MemberExpression {\n\treturn propertyNameOk(propertyName) ?\n\t\tnew MemberExpressionPlain(object, new Identifier(propertyName)) :\n\t\tnew MemberExpressionComputed(object, new LiteralString(propertyName))\n}\n\n/** An Identifier if propertyName is a valid JavaScript property name, otherwise a LiteralString. */\nexport function propertyIdOrLiteral(propertyName: string): Identifier | LiteralString {\n\treturn propertyNameOk(propertyName) ?\n\t\tnew Identifier(propertyName) :\n\t\tnew LiteralString(propertyName)\n}\n\n/**\nConvert a node into one that can be used as the content of a line.\n(esast requires all expression lines to be wrapped with [[ExpressionStatement]].)\n*/\nexport function toLineContent(ast: Statement | Declaration | Expression): Statement {\n\treturn ast instanceof Statement || ast instanceof Declaration ?\n\t\tast :\n\t\tnew ExpressionStatement(ast)\n}\n"],"sourceRoot":"/source/"}